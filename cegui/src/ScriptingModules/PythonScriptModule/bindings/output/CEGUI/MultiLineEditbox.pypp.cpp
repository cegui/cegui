// This file has been generated by Py++.

#include "boost/python.hpp"
#include "python_CEGUI.h"
#include "MultiLineEditbox.pypp.hpp"

namespace bp = boost::python;

struct MultiLineEditbox_wrapper : CEGUI::MultiLineEditbox, bp::wrapper< CEGUI::MultiLineEditbox > {

    MultiLineEditbox_wrapper(::CEGUI::String const & type, ::CEGUI::String const & name )
    : CEGUI::MultiLineEditbox( boost::ref(type), boost::ref(name) )
      , bp::wrapper< CEGUI::MultiLineEditbox >(){
        // constructor
    
    }

    virtual void initialiseComponents(  ) {
        if( bp::override func_initialiseComponents = this->get_override( "initialiseComponents" ) )
            func_initialiseComponents(  );
        else{
            this->CEGUI::MultiLineEditbox::initialiseComponents(  );
        }
    }
    
    void default_initialiseComponents(  ) {
        CEGUI::MultiLineEditbox::initialiseComponents( );
    }

    virtual void beginInitialisation(  ) {
        if( bp::override func_beginInitialisation = this->get_override( "beginInitialisation" ) )
            func_beginInitialisation(  );
        else{
            this->CEGUI::Window::beginInitialisation(  );
        }
    }
    
    void default_beginInitialisation(  ) {
        CEGUI::Window::beginInitialisation( );
    }

    virtual void cloneChildWidgetsTo( ::CEGUI::Window & target ) const  {
        if( bp::override func_cloneChildWidgetsTo = this->get_override( "cloneChildWidgetsTo" ) )
            func_cloneChildWidgetsTo( boost::ref(target) );
        else{
            this->CEGUI::Window::cloneChildWidgetsTo( boost::ref(target) );
        }
    }
    
    void default_cloneChildWidgetsTo( ::CEGUI::Window & target ) const  {
        CEGUI::Window::cloneChildWidgetsTo( boost::ref(target) );
    }

    virtual void clonePropertiesTo( ::CEGUI::Window & target ) const  {
        if( bp::override func_clonePropertiesTo = this->get_override( "clonePropertiesTo" ) )
            func_clonePropertiesTo( boost::ref(target) );
        else{
            this->CEGUI::Window::clonePropertiesTo( boost::ref(target) );
        }
    }
    
    void default_clonePropertiesTo( ::CEGUI::Window & target ) const  {
        CEGUI::Window::clonePropertiesTo( boost::ref(target) );
    }

    virtual void destroy(  ) {
        if( bp::override func_destroy = this->get_override( "destroy" ) )
            func_destroy(  );
        else{
            this->CEGUI::Window::destroy(  );
        }
    }
    
    void default_destroy(  ) {
        CEGUI::Window::destroy( );
    }

    virtual void endInitialisation(  ) {
        if( bp::override func_endInitialisation = this->get_override( "endInitialisation" ) )
            func_endInitialisation(  );
        else{
            this->CEGUI::Window::endInitialisation(  );
        }
    }
    
    void default_endInitialisation(  ) {
        CEGUI::Window::endInitialisation( );
    }

    virtual void fireEvent( ::CEGUI::String const & name, ::CEGUI::EventArgs & args, ::CEGUI::String const & eventNamespace="" ) {
        if( bp::override func_fireEvent = this->get_override( "fireEvent" ) )
            func_fireEvent( boost::ref(name), boost::ref(args), boost::ref(eventNamespace) );
        else{
            this->CEGUI::EventSet::fireEvent( boost::ref(name), boost::ref(args), boost::ref(eventNamespace) );
        }
    }
    
    void default_fireEvent( ::CEGUI::String const & name, ::CEGUI::EventArgs & args, ::CEGUI::String const & eventNamespace="" ) {
        CEGUI::EventSet::fireEvent( boost::ref(name), boost::ref(args), boost::ref(eventNamespace) );
    }

    virtual void getRenderingContext_impl( ::CEGUI::RenderingContext & ctx ) const  {
        if( bp::override func_getRenderingContext_impl = this->get_override( "getRenderingContext_impl" ) )
            func_getRenderingContext_impl( boost::ref(ctx) );
        else{
            this->CEGUI::Window::getRenderingContext_impl( boost::ref(ctx) );
        }
    }
    
    void default_getRenderingContext_impl( ::CEGUI::RenderingContext & ctx ) const  {
        CEGUI::Window::getRenderingContext_impl( boost::ref(ctx) );
    }

    virtual ::CEGUI::Rect< float > getUnclippedInnerRect_impl(  ) const  {
        if( bp::override func_getUnclippedInnerRect_impl = this->get_override( "getUnclippedInnerRect_impl" ) )
            return func_getUnclippedInnerRect_impl(  );
        else{
            return this->CEGUI::Window::getUnclippedInnerRect_impl(  );
        }
    }
    
    ::CEGUI::Rect< float > default_getUnclippedInnerRect_impl(  ) const  {
        return CEGUI::Window::getUnclippedInnerRect_impl( );
    }

    virtual bool isHit( ::CEGUI::Vector2< float > const & position, bool const allow_disabled=false ) const  {
        if( bp::override func_isHit = this->get_override( "isHit" ) )
            return func_isHit( boost::ref(position), allow_disabled );
        else{
            return this->CEGUI::Window::isHit( boost::ref(position), allow_disabled );
        }
    }
    
    bool default_isHit( ::CEGUI::Vector2< float > const & position, bool const allow_disabled=false ) const  {
        return CEGUI::Window::isHit( boost::ref(position), allow_disabled );
    }

    virtual void performChildWindowLayout(  ) {
        if( bp::override func_performChildWindowLayout = this->get_override( "performChildWindowLayout" ) )
            func_performChildWindowLayout(  );
        else{
            this->CEGUI::Window::performChildWindowLayout(  );
        }
    }
    
    void default_performChildWindowLayout(  ) {
        CEGUI::Window::performChildWindowLayout( );
    }

    virtual void setLookNFeel( ::CEGUI::String const & look ) {
        if( bp::override func_setLookNFeel = this->get_override( "setLookNFeel" ) )
            func_setLookNFeel( boost::ref(look) );
        else{
            this->CEGUI::Window::setLookNFeel( boost::ref(look) );
        }
    }
    
    void default_setLookNFeel( ::CEGUI::String const & look ) {
        CEGUI::Window::setLookNFeel( boost::ref(look) );
    }

    virtual void setMargin( ::CEGUI::UBox const & margin ) {
        if( bp::override func_setMargin = this->get_override( "setMargin" ) )
            func_setMargin( boost::ref(margin) );
        else{
            this->CEGUI::Window::setMargin( boost::ref(margin) );
        }
    }
    
    void default_setMargin( ::CEGUI::UBox const & margin ) {
        CEGUI::Window::setMargin( boost::ref(margin) );
    }

    virtual ::CEGUI::RefCounted< CEGUI::BoundSlot > subscribeScriptedEvent( ::CEGUI::String const & name, ::CEGUI::String const & subscriber_name ) {
        if( bp::override func_subscribeScriptedEvent = this->get_override( "subscribeScriptedEvent" ) )
            return func_subscribeScriptedEvent( boost::ref(name), boost::ref(subscriber_name) );
        else{
            return this->CEGUI::EventSet::subscribeScriptedEvent( boost::ref(name), boost::ref(subscriber_name) );
        }
    }
    
    ::CEGUI::RefCounted< CEGUI::BoundSlot > default_subscribeScriptedEvent( ::CEGUI::String const & name, ::CEGUI::String const & subscriber_name ) {
        return CEGUI::EventSet::subscribeScriptedEvent( boost::ref(name), boost::ref(subscriber_name) );
    }

    virtual ::CEGUI::RefCounted< CEGUI::BoundSlot > subscribeScriptedEvent( ::CEGUI::String const & name, unsigned int group, ::CEGUI::String const & subscriber_name ) {
        if( bp::override func_subscribeScriptedEvent = this->get_override( "subscribeScriptedEvent" ) )
            return func_subscribeScriptedEvent( boost::ref(name), group, boost::ref(subscriber_name) );
        else{
            return this->CEGUI::EventSet::subscribeScriptedEvent( boost::ref(name), group, boost::ref(subscriber_name) );
        }
    }
    
    ::CEGUI::RefCounted< CEGUI::BoundSlot > default_subscribeScriptedEvent( ::CEGUI::String const & name, unsigned int group, ::CEGUI::String const & subscriber_name ) {
        return CEGUI::EventSet::subscribeScriptedEvent( boost::ref(name), group, boost::ref(subscriber_name) );
    }

    virtual void update( float elapsed ) {
        if( bp::override func_update = this->get_override( "update" ) )
            func_update( elapsed );
        else{
            this->CEGUI::Window::update( elapsed );
        }
    }
    
    void default_update( float elapsed ) {
        CEGUI::Window::update( elapsed );
    }

    virtual void writeXMLToStream( ::CEGUI::XMLSerializer & xml_stream ) const  {
        if( bp::override func_writeXMLToStream = this->get_override( "writeXMLToStream" ) )
            func_writeXMLToStream( boost::ref(xml_stream) );
        else{
            this->CEGUI::Window::writeXMLToStream( boost::ref(xml_stream) );
        }
    }
    
    void default_writeXMLToStream( ::CEGUI::XMLSerializer & xml_stream ) const  {
        CEGUI::Window::writeXMLToStream( boost::ref(xml_stream) );
    }

};

void register_MultiLineEditbox_class(){

    { //::CEGUI::MultiLineEditbox
        typedef bp::class_< MultiLineEditbox_wrapper, bp::bases< CEGUI::Window >, boost::noncopyable > MultiLineEditbox_exposer_t;
        MultiLineEditbox_exposer_t MultiLineEditbox_exposer = MultiLineEditbox_exposer_t( "MultiLineEditbox", "*!\n\
        \n\
           Base class for the multi-line edit box widget.\n\
        *\n", bp::init< CEGUI::String const &, CEGUI::String const & >(( bp::arg("type"), bp::arg("name") ), "*************************************************************************\n\
           Construction and Destruction\n\
        *************************************************************************\n\
        *!\n\
        \n\
           Constructor for the MultiLineEditbox base class.\n\
        *\n") );
        bp::scope MultiLineEditbox_scope( MultiLineEditbox_exposer );
        { //::CEGUI::MultiLineEditbox::LineInfo
            typedef bp::class_< CEGUI::MultiLineEditbox::LineInfo > LineInfo_exposer_t;
            LineInfo_exposer_t LineInfo_exposer = LineInfo_exposer_t( "LineInfo", "*************************************************************************\n\
                Implementation struct\n\
            *************************************************************************\n\
            *!\n\
            \n\
                struct used to store information about a formatted line within the\n\
                paragraph.\n\
            *\n" );
            bp::scope LineInfo_scope( LineInfo_exposer );
            LineInfo_exposer.def_readwrite( "d_extent", &CEGUI::MultiLineEditbox::LineInfo::d_extent );
            LineInfo_exposer.def_readwrite( "d_length", &CEGUI::MultiLineEditbox::LineInfo::d_length );
            LineInfo_exposer.def_readwrite( "d_startIdx", &CEGUI::MultiLineEditbox::LineInfo::d_startIdx );
        }
        { //::CEGUI::MultiLineEditbox::ensureCaretIsVisible
        
            typedef void ( ::CEGUI::MultiLineEditbox::*ensureCaretIsVisible_function_type )(  ) ;
            
            MultiLineEditbox_exposer.def( 
                "ensureCaretIsVisible"
                , ensureCaretIsVisible_function_type( &::CEGUI::MultiLineEditbox::ensureCaretIsVisible )
                , "*!\n\
            \n\
               Scroll the view so that the current caret position is visible.\n\
            *\n" );
        
        }
        { //::CEGUI::MultiLineEditbox::getCaretIndex
        
            typedef ::size_t ( ::CEGUI::MultiLineEditbox::*getCaretIndex_function_type )(  ) const;
            
            MultiLineEditbox_exposer.def( 
                "getCaretIndex"
                , getCaretIndex_function_type( &::CEGUI::MultiLineEditbox::getCaretIndex )
                , "*!\n\
               \n\
                  return the current position of the caret.\n\
            \n\
               @return\n\
                  Index of the insert caret relative to the start of the text.\n\
               *\n" );
        
        }
        { //::CEGUI::MultiLineEditbox::getFormattedLines
        
            typedef ::std::vector< CEGUI::MultiLineEditbox::LineInfo > const & ( ::CEGUI::MultiLineEditbox::*getFormattedLines_function_type )(  ) const;
            
            MultiLineEditbox_exposer.def( 
                "getFormattedLines"
                , getFormattedLines_function_type( &::CEGUI::MultiLineEditbox::getFormattedLines )
                , bp::return_value_policy< bp::copy_const_reference >()
                , "get d_lines\n" );
        
        }
        { //::CEGUI::MultiLineEditbox::getHorzScrollbar
        
            typedef ::CEGUI::Scrollbar * ( ::CEGUI::MultiLineEditbox::*getHorzScrollbar_function_type )(  ) const;
            
            MultiLineEditbox_exposer.def( 
                "getHorzScrollbar"
                , getHorzScrollbar_function_type( &::CEGUI::MultiLineEditbox::getHorzScrollbar )
                , bp::return_value_policy< bp::reference_existing_object >()
                , "*!\n\
                \n\
                    Return a pointer to the horizontal scrollbar component widget for this\n\
                    MultiLineEditbox.\n\
            \n\
                @return\n\
                    Pointer to a Scrollbar object.\n\
            \n\
                @exception UnknownObjectException\n\
                    Thrown if the horizontal Scrollbar component does not exist.\n\
                *\n" );
        
        }
        { //::CEGUI::MultiLineEditbox::getLineNumberFromIndex
        
            typedef ::size_t ( ::CEGUI::MultiLineEditbox::*getLineNumberFromIndex_function_type )( ::size_t ) const;
            
            MultiLineEditbox_exposer.def( 
                "getLineNumberFromIndex"
                , getLineNumberFromIndex_function_type( &::CEGUI::MultiLineEditbox::getLineNumberFromIndex )
                , ( bp::arg("index") )
                , "*!\n\
            \n\
                Return the line number a given index falls on with the current formatting.  Will return last\
                line\n\
                if index is out of range.\n\
            *\n" );
        
        }
        { //::CEGUI::MultiLineEditbox::getMaxTextLength
        
            typedef ::size_t ( ::CEGUI::MultiLineEditbox::*getMaxTextLength_function_type )(  ) const;
            
            MultiLineEditbox_exposer.def( 
                "getMaxTextLength"
                , getMaxTextLength_function_type( &::CEGUI::MultiLineEditbox::getMaxTextLength )
                , "*!\n\
               \n\
                  return the maximum text length set for this edit box.\n\
            \n\
               @return\n\
                  The maximum number of code points (characters) that can be entered into this edit box.\n\
               *\n" );
        
        }
        { //::CEGUI::MultiLineEditbox::getSelectionBrushImage
        
            typedef ::CEGUI::Image const * ( ::CEGUI::MultiLineEditbox::*getSelectionBrushImage_function_type )(  ) const;
            
            MultiLineEditbox_exposer.def( 
                "getSelectionBrushImage"
                , getSelectionBrushImage_function_type( &::CEGUI::MultiLineEditbox::getSelectionBrushImage )
                , bp::return_value_policy< bp::reference_existing_object >()
                , "selection brush image property support\n" );
        
        }
        { //::CEGUI::MultiLineEditbox::getSelectionEndIndex
        
            typedef ::size_t ( ::CEGUI::MultiLineEditbox::*getSelectionEndIndex_function_type )(  ) const;
            
            MultiLineEditbox_exposer.def( 
                "getSelectionEndIndex"
                , getSelectionEndIndex_function_type( &::CEGUI::MultiLineEditbox::getSelectionEndIndex )
                , "*!\n\
               \n\
                  return the current selection end point.\n\
            \n\
               @return\n\
                  Index of the selection end point relative to the start of the text.  If no selection is\
                  defined this function returns\n\
                  the position of the caret.\n\
               *\n" );
        
        }
        { //::CEGUI::MultiLineEditbox::getSelectionLength
        
            typedef ::size_t ( ::CEGUI::MultiLineEditbox::*getSelectionLength_function_type )(  ) const;
            
            MultiLineEditbox_exposer.def( 
                "getSelectionLength"
                , getSelectionLength_function_type( &::CEGUI::MultiLineEditbox::getSelectionLength )
                , "*!\n\
               \n\
                  return the length of the current selection (in code points  characters).\n\
            \n\
               @return\n\
                  Number of code points (or characters) contained within the currently defined selection.\n\
               *\n" );
        
        }
        { //::CEGUI::MultiLineEditbox::getSelectionStartIndex
        
            typedef ::size_t ( ::CEGUI::MultiLineEditbox::*getSelectionStartIndex_function_type )(  ) const;
            
            MultiLineEditbox_exposer.def( 
                "getSelectionStartIndex"
                , getSelectionStartIndex_function_type( &::CEGUI::MultiLineEditbox::getSelectionStartIndex )
                , "*!\n\
               \n\
                  return the current selection start point.\n\
            \n\
               @return\n\
                  Index of the selection start point relative to the start of the text.  If no selection is\
                  defined this function returns\n\
                  the position of the caret.\n\
               *\n" );
        
        }
        { //::CEGUI::MultiLineEditbox::getTextRenderArea
        
            typedef ::CEGUI::Rect< float > ( ::CEGUI::MultiLineEditbox::*getTextRenderArea_function_type )(  ) const;
            
            MultiLineEditbox_exposer.def( 
                "getTextRenderArea"
                , getTextRenderArea_function_type( &::CEGUI::MultiLineEditbox::getTextRenderArea )
                , "*!\n\
                \n\
                    Return a Rect object describing, in un-clipped pixels, the window relative area\n\
                    that the text should be rendered in to.\n\
            \n\
                @return\n\
                    Rect object describing the area of the Window to be used for rendering text.\n\
                *\n" );
        
        }
        { //::CEGUI::MultiLineEditbox::getVertScrollbar
        
            typedef ::CEGUI::Scrollbar * ( ::CEGUI::MultiLineEditbox::*getVertScrollbar_function_type )(  ) const;
            
            MultiLineEditbox_exposer.def( 
                "getVertScrollbar"
                , getVertScrollbar_function_type( &::CEGUI::MultiLineEditbox::getVertScrollbar )
                , bp::return_value_policy< bp::reference_existing_object >()
                , "*!\n\
                \n\
                    Return a pointer to the vertical scrollbar component widget for this\n\
                    MultiLineEditbox.\n\
            \n\
                @return\n\
                    Pointer to a Scrollbar object.\n\
            \n\
                @exception UnknownObjectException\n\
                    Thrown if the vertical Scrollbar component does not exist.\n\
                *\n" );
        
        }
        { //::CEGUI::MultiLineEditbox::hasInputFocus
        
            typedef bool ( ::CEGUI::MultiLineEditbox::*hasInputFocus_function_type )(  ) const;
            
            MultiLineEditbox_exposer.def( 
                "hasInputFocus"
                , hasInputFocus_function_type( &::CEGUI::MultiLineEditbox::hasInputFocus )
                , "*************************************************************************\n\
                  Accessor Functions\n\
               *************************************************************************\n\
               *!\n\
               \n\
                  return true if the edit box has input focus.\n\
            \n\
               @return\n\
                  - true if the edit box has keyboard input focus.\n\
                  - false if the edit box does not have keyboard input focus.\n\
               *\n" );
        
        }
        { //::CEGUI::MultiLineEditbox::initialiseComponents
        
            typedef void ( ::CEGUI::MultiLineEditbox::*initialiseComponents_function_type )(  ) ;
            typedef void ( MultiLineEditbox_wrapper::*default_initialiseComponents_function_type )(  ) ;
            
            MultiLineEditbox_exposer.def( 
                "initialiseComponents"
                , initialiseComponents_function_type(&::CEGUI::MultiLineEditbox::initialiseComponents)
                , default_initialiseComponents_function_type(&MultiLineEditbox_wrapper::default_initialiseComponents) );
        
        }
        { //::CEGUI::MultiLineEditbox::isReadOnly
        
            typedef bool ( ::CEGUI::MultiLineEditbox::*isReadOnly_function_type )(  ) const;
            
            MultiLineEditbox_exposer.def( 
                "isReadOnly"
                , isReadOnly_function_type( &::CEGUI::MultiLineEditbox::isReadOnly )
                , "*!\n\
               \n\
                  return true if the edit box is read-only.\n\
            \n\
               @return\n\
                  - true if the edit box is read only and can't be edited by the user.\n\
                  - false if the edit box is not read only and may be edited by the user.\n\
               *\n" );
        
        }
        { //::CEGUI::MultiLineEditbox::isVertScrollbarAlwaysShown
        
            typedef bool ( ::CEGUI::MultiLineEditbox::*isVertScrollbarAlwaysShown_function_type )(  ) const;
            
            MultiLineEditbox_exposer.def( 
                "isVertScrollbarAlwaysShown"
                , isVertScrollbarAlwaysShown_function_type( &::CEGUI::MultiLineEditbox::isVertScrollbarAlwaysShown )
                , "*!\n\
               \n\
                  Return whether the vertical scroll bar is always shown.\n\
            \n\
               @return\n\
                  - true if the scroll bar will always be shown even if it is not required.\n\
                  - false if the scroll bar will only be shown when it is required.\n\
               *\n" );
        
        }
        { //::CEGUI::MultiLineEditbox::isWordWrapped
        
            typedef bool ( ::CEGUI::MultiLineEditbox::*isWordWrapped_function_type )(  ) const;
            
            MultiLineEditbox_exposer.def( 
                "isWordWrapped"
                , isWordWrapped_function_type( &::CEGUI::MultiLineEditbox::isWordWrapped )
                , "*!\n\
               \n\
                  Return whether the text in the edit box will be word-wrapped.\n\
            \n\
               @return\n\
                  - true if the text will be word-wrapped at the edges of the widget frame.\n\
                  - false if text will not be word-wrapped (a scroll bar will be used to access long text\
                  lines).\n\
               *\n" );
        
        }
        { //::CEGUI::MultiLineEditbox::setCaretIndex
        
            typedef void ( ::CEGUI::MultiLineEditbox::*setCaretIndex_function_type )( ::size_t ) ;
            
            MultiLineEditbox_exposer.def( 
                "setCaretIndex"
                , setCaretIndex_function_type( &::CEGUI::MultiLineEditbox::setCaretIndex )
                , ( bp::arg("caret_pos") )
                , "*!\n\
               \n\
                  Set the current position of the caret.\n\
            \n\
               @param caret_pos\n\
                  New index for the insert caret relative to the start of the text.  If the value specified is\
                  greater than the\n\
                  number of characters in the edit box, the caret is positioned at the end of the text.\n\
            \n\
               @return\n\
                  Nothing.\n\
               *\n" );
        
        }
        { //::CEGUI::MultiLineEditbox::setMaxTextLength
        
            typedef void ( ::CEGUI::MultiLineEditbox::*setMaxTextLength_function_type )( ::size_t ) ;
            
            MultiLineEditbox_exposer.def( 
                "setMaxTextLength"
                , setMaxTextLength_function_type( &::CEGUI::MultiLineEditbox::setMaxTextLength )
                , ( bp::arg("max_len") )
                , "*!\n\
               \n\
                  set the maximum text length for this edit box.\n\
            \n\
               @param max_len\n\
                  The maximum number of code points (characters) that can be entered into this Editbox.\n\
            \n\
               @return\n\
                  Nothing.\n\
               *\n" );
        
        }
        { //::CEGUI::MultiLineEditbox::setReadOnly
        
            typedef void ( ::CEGUI::MultiLineEditbox::*setReadOnly_function_type )( bool ) ;
            
            MultiLineEditbox_exposer.def( 
                "setReadOnly"
                , setReadOnly_function_type( &::CEGUI::MultiLineEditbox::setReadOnly )
                , ( bp::arg("setting") )
                , "*!\n\
               \n\
                  Specify whether the edit box is read-only.\n\
            \n\
               @param setting\n\
                  - true if the edit box is read only and can't be edited by the user.\n\
                  - false if the edit box is not read only and may be edited by the user.\n\
            \n\
               @return\n\
                  Nothing.\n\
               *\n" );
        
        }
        { //::CEGUI::MultiLineEditbox::setSelection
        
            typedef void ( ::CEGUI::MultiLineEditbox::*setSelection_function_type )( ::size_t,::size_t ) ;
            
            MultiLineEditbox_exposer.def( 
                "setSelection"
                , setSelection_function_type( &::CEGUI::MultiLineEditbox::setSelection )
                , ( bp::arg("start_pos"), bp::arg("end_pos") )
                , "*!\n\
               \n\
                  Define the current selection for the edit box\n\
            \n\
               @param start_pos\n\
                  Index of the starting point for the selection.  If this value is greater than the number of\
                  characters in the edit box, the\n\
                  selection start will be set to the end of the text.\n\
            \n\
               @param end_pos\n\
                  Index of the ending point for the selection.  If this value is greater than the number of\
                  characters in the edit box, the\n\
                  selection start will be set to the end of the text.\n\
            \n\
               @return\n\
                  Nothing.\n\
               *\n" );
        
        }
        { //::CEGUI::MultiLineEditbox::setSelectionBrushImage
        
            typedef void ( ::CEGUI::MultiLineEditbox::*setSelectionBrushImage_function_type )( ::CEGUI::Image const * ) ;
            
            MultiLineEditbox_exposer.def( 
                "setSelectionBrushImage"
                , setSelectionBrushImage_function_type( &::CEGUI::MultiLineEditbox::setSelectionBrushImage )
                , ( bp::arg("image") )
                , "selection brush image property support\n" );
        
        }
        { //::CEGUI::MultiLineEditbox::setShowVertScrollbar
        
            typedef void ( ::CEGUI::MultiLineEditbox::*setShowVertScrollbar_function_type )( bool ) ;
            
            MultiLineEditbox_exposer.def( 
                "setShowVertScrollbar"
                , setShowVertScrollbar_function_type( &::CEGUI::MultiLineEditbox::setShowVertScrollbar )
                , ( bp::arg("setting") )
                , "*!\n\
               \n\
                  Set whether the vertical scroll bar should always be shown.\n\
            \n\
               @param setting\n\
                  true if the vertical scroll bar should be shown even when it is not required.  false if the\
                  vertical\n\
                  scroll bar should only be shown when it is required.\n\
            \n\
               @return\n\
                  Nothing.\n\
               *\n" );
        
        }
        { //::CEGUI::MultiLineEditbox::setWordWrapping
        
            typedef void ( ::CEGUI::MultiLineEditbox::*setWordWrapping_function_type )( bool ) ;
            
            MultiLineEditbox_exposer.def( 
                "setWordWrapping"
                , setWordWrapping_function_type( &::CEGUI::MultiLineEditbox::setWordWrapping )
                , ( bp::arg("setting") )
                , "*!\n\
               \n\
                  Set whether the text will be word wrapped or not.\n\
            \n\
               @param setting\n\
                  - true if the text should word-wrap at the edges of the text box.\n\
                  - false if the text should not wrap, but a scroll bar should be used.\n\
            \n\
               @return\n\
                  Nothing.\n\
               *\n" );
        
        }
        MultiLineEditbox_exposer.add_static_property( "EventCaretMoved"
                        , bp::make_getter( &CEGUI::MultiLineEditbox::EventCaretMoved
                                , bp::return_value_policy< bp::return_by_value >() ) );
        MultiLineEditbox_exposer.add_static_property( "EventEditboxFull"
                        , bp::make_getter( &CEGUI::MultiLineEditbox::EventEditboxFull
                                , bp::return_value_policy< bp::return_by_value >() ) );
        MultiLineEditbox_exposer.add_static_property( "EventHorzScrollbarModeChanged"
                        , bp::make_getter( &CEGUI::MultiLineEditbox::EventHorzScrollbarModeChanged
                                , bp::return_value_policy< bp::return_by_value >() ) );
        MultiLineEditbox_exposer.add_static_property( "EventMaximumTextLengthChanged"
                        , bp::make_getter( &CEGUI::MultiLineEditbox::EventMaximumTextLengthChanged
                                , bp::return_value_policy< bp::return_by_value >() ) );
        MultiLineEditbox_exposer.add_static_property( "EventReadOnlyModeChanged"
                        , bp::make_getter( &CEGUI::MultiLineEditbox::EventReadOnlyModeChanged
                                , bp::return_value_policy< bp::return_by_value >() ) );
        MultiLineEditbox_exposer.add_static_property( "EventTextSelectionChanged"
                        , bp::make_getter( &CEGUI::MultiLineEditbox::EventTextSelectionChanged
                                , bp::return_value_policy< bp::return_by_value >() ) );
        MultiLineEditbox_exposer.add_static_property( "EventVertScrollbarModeChanged"
                        , bp::make_getter( &CEGUI::MultiLineEditbox::EventVertScrollbarModeChanged
                                , bp::return_value_policy< bp::return_by_value >() ) );
        MultiLineEditbox_exposer.add_static_property( "EventWordWrapModeChanged"
                        , bp::make_getter( &CEGUI::MultiLineEditbox::EventWordWrapModeChanged
                                , bp::return_value_policy< bp::return_by_value >() ) );
        MultiLineEditbox_exposer.add_static_property( "HorzScrollbarNameSuffix"
                        , bp::make_getter( &CEGUI::MultiLineEditbox::HorzScrollbarNameSuffix
                                , bp::return_value_policy< bp::return_by_value >() ) );
        MultiLineEditbox_exposer.add_static_property( "VertScrollbarNameSuffix"
                        , bp::make_getter( &CEGUI::MultiLineEditbox::VertScrollbarNameSuffix
                                , bp::return_value_policy< bp::return_by_value >() ) );
        { //::CEGUI::Window::beginInitialisation
        
            typedef void ( ::CEGUI::Window::*beginInitialisation_function_type )(  ) ;
            typedef void ( MultiLineEditbox_wrapper::*default_beginInitialisation_function_type )(  ) ;
            
            MultiLineEditbox_exposer.def( 
                "beginInitialisation"
                , beginInitialisation_function_type(&::CEGUI::Window::beginInitialisation)
                , default_beginInitialisation_function_type(&MultiLineEditbox_wrapper::default_beginInitialisation) );
        
        }
        { //::CEGUI::Window::cloneChildWidgetsTo
        
            typedef void ( ::CEGUI::Window::*cloneChildWidgetsTo_function_type )( ::CEGUI::Window & ) const;
            typedef void ( MultiLineEditbox_wrapper::*default_cloneChildWidgetsTo_function_type )( ::CEGUI::Window & ) const;
            
            MultiLineEditbox_exposer.def( 
                "cloneChildWidgetsTo"
                , cloneChildWidgetsTo_function_type(&::CEGUI::Window::cloneChildWidgetsTo)
                , default_cloneChildWidgetsTo_function_type(&MultiLineEditbox_wrapper::default_cloneChildWidgetsTo)
                , ( bp::arg("target") ) );
        
        }
        { //::CEGUI::Window::clonePropertiesTo
        
            typedef void ( ::CEGUI::Window::*clonePropertiesTo_function_type )( ::CEGUI::Window & ) const;
            typedef void ( MultiLineEditbox_wrapper::*default_clonePropertiesTo_function_type )( ::CEGUI::Window & ) const;
            
            MultiLineEditbox_exposer.def( 
                "clonePropertiesTo"
                , clonePropertiesTo_function_type(&::CEGUI::Window::clonePropertiesTo)
                , default_clonePropertiesTo_function_type(&MultiLineEditbox_wrapper::default_clonePropertiesTo)
                , ( bp::arg("target") ) );
        
        }
        { //::CEGUI::Window::destroy
        
            typedef void ( ::CEGUI::Window::*destroy_function_type )(  ) ;
            typedef void ( MultiLineEditbox_wrapper::*default_destroy_function_type )(  ) ;
            
            MultiLineEditbox_exposer.def( 
                "destroy"
                , destroy_function_type(&::CEGUI::Window::destroy)
                , default_destroy_function_type(&MultiLineEditbox_wrapper::default_destroy) );
        
        }
        { //::CEGUI::Window::endInitialisation
        
            typedef void ( ::CEGUI::Window::*endInitialisation_function_type )(  ) ;
            typedef void ( MultiLineEditbox_wrapper::*default_endInitialisation_function_type )(  ) ;
            
            MultiLineEditbox_exposer.def( 
                "endInitialisation"
                , endInitialisation_function_type(&::CEGUI::Window::endInitialisation)
                , default_endInitialisation_function_type(&MultiLineEditbox_wrapper::default_endInitialisation) );
        
        }
        { //::CEGUI::EventSet::fireEvent
        
            typedef void ( ::CEGUI::EventSet::*fireEvent_function_type )( ::CEGUI::String const &,::CEGUI::EventArgs &,::CEGUI::String const & ) ;
            typedef void ( MultiLineEditbox_wrapper::*default_fireEvent_function_type )( ::CEGUI::String const &,::CEGUI::EventArgs &,::CEGUI::String const & ) ;
            
            MultiLineEditbox_exposer.def( 
                "fireEvent"
                , fireEvent_function_type(&::CEGUI::EventSet::fireEvent)
                , default_fireEvent_function_type(&MultiLineEditbox_wrapper::default_fireEvent)
                , ( bp::arg("name"), bp::arg("args"), bp::arg("eventNamespace")="" ) );
        
        }
        { //::CEGUI::Window::getRenderedStringParser
        
            typedef ::CEGUI::RenderedStringParser & ( ::CEGUI::Window::*getRenderedStringParser_function_type )(  ) const;
            
            MultiLineEditbox_exposer.def( 
                "getRenderedStringParser"
                , getRenderedStringParser_function_type(&::CEGUI::Window::getRenderedStringParser)
                , bp::return_value_policy< bp::reference_existing_object >() );
        
        }
        { //::CEGUI::Window::getRenderingContext_impl
        
            typedef void ( ::CEGUI::Window::*getRenderingContext_impl_function_type )( ::CEGUI::RenderingContext & ) const;
            typedef void ( MultiLineEditbox_wrapper::*default_getRenderingContext_impl_function_type )( ::CEGUI::RenderingContext & ) const;
            
            MultiLineEditbox_exposer.def( 
                "getRenderingContext_impl"
                , getRenderingContext_impl_function_type(&::CEGUI::Window::getRenderingContext_impl)
                , default_getRenderingContext_impl_function_type(&MultiLineEditbox_wrapper::default_getRenderingContext_impl)
                , ( bp::arg("ctx") ) );
        
        }
        { //::CEGUI::Window::getUnclippedInnerRect_impl
        
            typedef ::CEGUI::Rect< float > ( ::CEGUI::Window::*getUnclippedInnerRect_impl_function_type )(  ) const;
            typedef ::CEGUI::Rect< float > ( MultiLineEditbox_wrapper::*default_getUnclippedInnerRect_impl_function_type )(  ) const;
            
            MultiLineEditbox_exposer.def( 
                "getUnclippedInnerRect_impl"
                , getUnclippedInnerRect_impl_function_type(&::CEGUI::Window::getUnclippedInnerRect_impl)
                , default_getUnclippedInnerRect_impl_function_type(&MultiLineEditbox_wrapper::default_getUnclippedInnerRect_impl) );
        
        }
        { //::CEGUI::Window::isHit
        
            typedef bool ( ::CEGUI::Window::*isHit_function_type )( ::CEGUI::Vector2< float > const &,bool const ) const;
            typedef bool ( MultiLineEditbox_wrapper::*default_isHit_function_type )( ::CEGUI::Vector2< float > const &,bool const ) const;
            
            MultiLineEditbox_exposer.def( 
                "isHit"
                , isHit_function_type(&::CEGUI::Window::isHit)
                , default_isHit_function_type(&MultiLineEditbox_wrapper::default_isHit)
                , ( bp::arg("position"), bp::arg("allow_disabled")=(bool const)(false) ) );
        
        }
        { //::CEGUI::Window::performChildWindowLayout
        
            typedef void ( ::CEGUI::Window::*performChildWindowLayout_function_type )(  ) ;
            typedef void ( MultiLineEditbox_wrapper::*default_performChildWindowLayout_function_type )(  ) ;
            
            MultiLineEditbox_exposer.def( 
                "performChildWindowLayout"
                , performChildWindowLayout_function_type(&::CEGUI::Window::performChildWindowLayout)
                , default_performChildWindowLayout_function_type(&MultiLineEditbox_wrapper::default_performChildWindowLayout) );
        
        }
        { //::CEGUI::Window::setLookNFeel
        
            typedef void ( ::CEGUI::Window::*setLookNFeel_function_type )( ::CEGUI::String const & ) ;
            typedef void ( MultiLineEditbox_wrapper::*default_setLookNFeel_function_type )( ::CEGUI::String const & ) ;
            
            MultiLineEditbox_exposer.def( 
                "setLookNFeel"
                , setLookNFeel_function_type(&::CEGUI::Window::setLookNFeel)
                , default_setLookNFeel_function_type(&MultiLineEditbox_wrapper::default_setLookNFeel)
                , ( bp::arg("look") ) );
        
        }
        { //::CEGUI::Window::setMargin
        
            typedef void ( ::CEGUI::Window::*setMargin_function_type )( ::CEGUI::UBox const & ) ;
            typedef void ( MultiLineEditbox_wrapper::*default_setMargin_function_type )( ::CEGUI::UBox const & ) ;
            
            MultiLineEditbox_exposer.def( 
                "setMargin"
                , setMargin_function_type(&::CEGUI::Window::setMargin)
                , default_setMargin_function_type(&MultiLineEditbox_wrapper::default_setMargin)
                , ( bp::arg("margin") ) );
        
        }
        { //::CEGUI::EventSet::subscribeScriptedEvent
        
            typedef ::CEGUI::RefCounted< CEGUI::BoundSlot > ( ::CEGUI::EventSet::*subscribeScriptedEvent_function_type )( ::CEGUI::String const &,::CEGUI::String const & ) ;
            typedef ::CEGUI::RefCounted< CEGUI::BoundSlot > ( MultiLineEditbox_wrapper::*default_subscribeScriptedEvent_function_type )( ::CEGUI::String const &,::CEGUI::String const & ) ;
            
            MultiLineEditbox_exposer.def( 
                "subscribeScriptedEvent"
                , subscribeScriptedEvent_function_type(&::CEGUI::EventSet::subscribeScriptedEvent)
                , default_subscribeScriptedEvent_function_type(&MultiLineEditbox_wrapper::default_subscribeScriptedEvent)
                , ( bp::arg("name"), bp::arg("subscriber_name") ) );
        
        }
        { //::CEGUI::EventSet::subscribeScriptedEvent
        
            typedef ::CEGUI::RefCounted< CEGUI::BoundSlot > ( ::CEGUI::EventSet::*subscribeScriptedEvent_function_type )( ::CEGUI::String const &,unsigned int,::CEGUI::String const & ) ;
            typedef ::CEGUI::RefCounted< CEGUI::BoundSlot > ( MultiLineEditbox_wrapper::*default_subscribeScriptedEvent_function_type )( ::CEGUI::String const &,unsigned int,::CEGUI::String const & ) ;
            
            MultiLineEditbox_exposer.def( 
                "subscribeScriptedEvent"
                , subscribeScriptedEvent_function_type(&::CEGUI::EventSet::subscribeScriptedEvent)
                , default_subscribeScriptedEvent_function_type(&MultiLineEditbox_wrapper::default_subscribeScriptedEvent)
                , ( bp::arg("name"), bp::arg("group"), bp::arg("subscriber_name") ) );
        
        }
        { //::CEGUI::Window::update
        
            typedef void ( ::CEGUI::Window::*update_function_type )( float ) ;
            typedef void ( MultiLineEditbox_wrapper::*default_update_function_type )( float ) ;
            
            MultiLineEditbox_exposer.def( 
                "update"
                , update_function_type(&::CEGUI::Window::update)
                , default_update_function_type(&MultiLineEditbox_wrapper::default_update)
                , ( bp::arg("elapsed") ) );
        
        }
        { //::CEGUI::Window::writeXMLToStream
        
            typedef void ( ::CEGUI::Window::*writeXMLToStream_function_type )( ::CEGUI::XMLSerializer & ) const;
            typedef void ( MultiLineEditbox_wrapper::*default_writeXMLToStream_function_type )( ::CEGUI::XMLSerializer & ) const;
            
            MultiLineEditbox_exposer.def( 
                "writeXMLToStream"
                , writeXMLToStream_function_type(&::CEGUI::Window::writeXMLToStream)
                , default_writeXMLToStream_function_type(&MultiLineEditbox_wrapper::default_writeXMLToStream)
                , ( bp::arg("xml_stream") ) );
        
        }
    }

}
