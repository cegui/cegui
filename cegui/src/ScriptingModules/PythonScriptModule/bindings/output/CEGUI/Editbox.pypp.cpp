// This file has been generated by Py++.

#include "boost/python.hpp"
#include "python_CEGUI.h"
#include "Editbox.pypp.hpp"

namespace bp = boost::python;

struct Editbox_wrapper : CEGUI::Editbox, bp::wrapper< CEGUI::Editbox > {

    Editbox_wrapper(::CEGUI::String const & type, ::CEGUI::String const & name )
    : CEGUI::Editbox( boost::ref(type), boost::ref(name) )
      , bp::wrapper< CEGUI::Editbox >(){
        // constructor
    
    }

    virtual void beginInitialisation(  ) {
        if( bp::override func_beginInitialisation = this->get_override( "beginInitialisation" ) )
            func_beginInitialisation(  );
        else{
            this->CEGUI::Window::beginInitialisation(  );
        }
    }
    
    void default_beginInitialisation(  ) {
        CEGUI::Window::beginInitialisation( );
    }

    virtual void cloneChildWidgetsTo( ::CEGUI::Window & target ) const  {
        if( bp::override func_cloneChildWidgetsTo = this->get_override( "cloneChildWidgetsTo" ) )
            func_cloneChildWidgetsTo( boost::ref(target) );
        else{
            this->CEGUI::Window::cloneChildWidgetsTo( boost::ref(target) );
        }
    }
    
    void default_cloneChildWidgetsTo( ::CEGUI::Window & target ) const  {
        CEGUI::Window::cloneChildWidgetsTo( boost::ref(target) );
    }

    virtual void clonePropertiesTo( ::CEGUI::Window & target ) const  {
        if( bp::override func_clonePropertiesTo = this->get_override( "clonePropertiesTo" ) )
            func_clonePropertiesTo( boost::ref(target) );
        else{
            this->CEGUI::Window::clonePropertiesTo( boost::ref(target) );
        }
    }
    
    void default_clonePropertiesTo( ::CEGUI::Window & target ) const  {
        CEGUI::Window::clonePropertiesTo( boost::ref(target) );
    }

    virtual void destroy(  ) {
        if( bp::override func_destroy = this->get_override( "destroy" ) )
            func_destroy(  );
        else{
            this->CEGUI::Window::destroy(  );
        }
    }
    
    void default_destroy(  ) {
        CEGUI::Window::destroy( );
    }

    virtual void endInitialisation(  ) {
        if( bp::override func_endInitialisation = this->get_override( "endInitialisation" ) )
            func_endInitialisation(  );
        else{
            this->CEGUI::Window::endInitialisation(  );
        }
    }
    
    void default_endInitialisation(  ) {
        CEGUI::Window::endInitialisation( );
    }

    virtual void fireEvent( ::CEGUI::String const & name, ::CEGUI::EventArgs & args, ::CEGUI::String const & eventNamespace="" ) {
        if( bp::override func_fireEvent = this->get_override( "fireEvent" ) )
            func_fireEvent( boost::ref(name), boost::ref(args), boost::ref(eventNamespace) );
        else{
            this->CEGUI::EventSet::fireEvent( boost::ref(name), boost::ref(args), boost::ref(eventNamespace) );
        }
    }
    
    void default_fireEvent( ::CEGUI::String const & name, ::CEGUI::EventArgs & args, ::CEGUI::String const & eventNamespace="" ) {
        CEGUI::EventSet::fireEvent( boost::ref(name), boost::ref(args), boost::ref(eventNamespace) );
    }

    virtual void getRenderingContext_impl( ::CEGUI::RenderingContext & ctx ) const  {
        if( bp::override func_getRenderingContext_impl = this->get_override( "getRenderingContext_impl" ) )
            func_getRenderingContext_impl( boost::ref(ctx) );
        else{
            this->CEGUI::Window::getRenderingContext_impl( boost::ref(ctx) );
        }
    }
    
    void default_getRenderingContext_impl( ::CEGUI::RenderingContext & ctx ) const  {
        CEGUI::Window::getRenderingContext_impl( boost::ref(ctx) );
    }

    virtual ::CEGUI::Rect getUnclippedInnerRect_impl(  ) const  {
        if( bp::override func_getUnclippedInnerRect_impl = this->get_override( "getUnclippedInnerRect_impl" ) )
            return func_getUnclippedInnerRect_impl(  );
        else{
            return this->CEGUI::Window::getUnclippedInnerRect_impl(  );
        }
    }
    
    ::CEGUI::Rect default_getUnclippedInnerRect_impl(  ) const  {
        return CEGUI::Window::getUnclippedInnerRect_impl( );
    }

    virtual void initialiseComponents(  ) {
        if( bp::override func_initialiseComponents = this->get_override( "initialiseComponents" ) )
            func_initialiseComponents(  );
        else{
            this->CEGUI::Window::initialiseComponents(  );
        }
    }
    
    void default_initialiseComponents(  ) {
        CEGUI::Window::initialiseComponents( );
    }

    virtual bool isHit( ::CEGUI::Vector2 const & position, bool const allow_disabled=false ) const  {
        if( bp::override func_isHit = this->get_override( "isHit" ) )
            return func_isHit( boost::ref(position), allow_disabled );
        else{
            return this->CEGUI::Window::isHit( boost::ref(position), allow_disabled );
        }
    }
    
    bool default_isHit( ::CEGUI::Vector2 const & position, bool const allow_disabled=false ) const  {
        return CEGUI::Window::isHit( boost::ref(position), allow_disabled );
    }

    virtual void performChildWindowLayout(  ) {
        if( bp::override func_performChildWindowLayout = this->get_override( "performChildWindowLayout" ) )
            func_performChildWindowLayout(  );
        else{
            this->CEGUI::Window::performChildWindowLayout(  );
        }
    }
    
    void default_performChildWindowLayout(  ) {
        CEGUI::Window::performChildWindowLayout( );
    }

    virtual void setLookNFeel( ::CEGUI::String const & look ) {
        if( bp::override func_setLookNFeel = this->get_override( "setLookNFeel" ) )
            func_setLookNFeel( boost::ref(look) );
        else{
            this->CEGUI::Window::setLookNFeel( boost::ref(look) );
        }
    }
    
    void default_setLookNFeel( ::CEGUI::String const & look ) {
        CEGUI::Window::setLookNFeel( boost::ref(look) );
    }

    virtual void setMargin( ::CEGUI::UBox const & margin ) {
        if( bp::override func_setMargin = this->get_override( "setMargin" ) )
            func_setMargin( boost::ref(margin) );
        else{
            this->CEGUI::Window::setMargin( boost::ref(margin) );
        }
    }
    
    void default_setMargin( ::CEGUI::UBox const & margin ) {
        CEGUI::Window::setMargin( boost::ref(margin) );
    }

    virtual ::CEGUI::RefCounted< CEGUI::BoundSlot > subscribeScriptedEvent( ::CEGUI::String const & name, ::CEGUI::String const & subscriber_name ) {
        if( bp::override func_subscribeScriptedEvent = this->get_override( "subscribeScriptedEvent" ) )
            return func_subscribeScriptedEvent( boost::ref(name), boost::ref(subscriber_name) );
        else{
            return this->CEGUI::EventSet::subscribeScriptedEvent( boost::ref(name), boost::ref(subscriber_name) );
        }
    }
    
    ::CEGUI::RefCounted< CEGUI::BoundSlot > default_subscribeScriptedEvent( ::CEGUI::String const & name, ::CEGUI::String const & subscriber_name ) {
        return CEGUI::EventSet::subscribeScriptedEvent( boost::ref(name), boost::ref(subscriber_name) );
    }

    virtual ::CEGUI::RefCounted< CEGUI::BoundSlot > subscribeScriptedEvent( ::CEGUI::String const & name, unsigned int group, ::CEGUI::String const & subscriber_name ) {
        if( bp::override func_subscribeScriptedEvent = this->get_override( "subscribeScriptedEvent" ) )
            return func_subscribeScriptedEvent( boost::ref(name), group, boost::ref(subscriber_name) );
        else{
            return this->CEGUI::EventSet::subscribeScriptedEvent( boost::ref(name), group, boost::ref(subscriber_name) );
        }
    }
    
    ::CEGUI::RefCounted< CEGUI::BoundSlot > default_subscribeScriptedEvent( ::CEGUI::String const & name, unsigned int group, ::CEGUI::String const & subscriber_name ) {
        return CEGUI::EventSet::subscribeScriptedEvent( boost::ref(name), group, boost::ref(subscriber_name) );
    }

    virtual void update( float elapsed ) {
        if( bp::override func_update = this->get_override( "update" ) )
            func_update( elapsed );
        else{
            this->CEGUI::Window::update( elapsed );
        }
    }
    
    void default_update( float elapsed ) {
        CEGUI::Window::update( elapsed );
    }

    virtual void writeXMLToStream( ::CEGUI::XMLSerializer & xml_stream ) const  {
        if( bp::override func_writeXMLToStream = this->get_override( "writeXMLToStream" ) )
            func_writeXMLToStream( boost::ref(xml_stream) );
        else{
            this->CEGUI::Window::writeXMLToStream( boost::ref(xml_stream) );
        }
    }
    
    void default_writeXMLToStream( ::CEGUI::XMLSerializer & xml_stream ) const  {
        CEGUI::Window::writeXMLToStream( boost::ref(xml_stream) );
    }

};

void register_Editbox_class(){

    { //::CEGUI::Editbox
        typedef bp::class_< Editbox_wrapper, bp::bases< CEGUI::Window >, boost::noncopyable > Editbox_exposer_t;
        Editbox_exposer_t Editbox_exposer = Editbox_exposer_t( "Editbox", "! Base class for an Editbox widget\n", bp::init< CEGUI::String const &, CEGUI::String const & >(( bp::arg("type"), bp::arg("name") ), "! Constructor for Editbox class.\n") );
        bp::scope Editbox_scope( Editbox_exposer );
        { //::CEGUI::Editbox::getCaretIndex
        
            typedef ::size_t ( ::CEGUI::Editbox::*getCaretIndex_function_type )(  ) const;
            
            Editbox_exposer.def( 
                "getCaretIndex"
                , getCaretIndex_function_type( &::CEGUI::Editbox::getCaretIndex )
                , "*!\n\
                \n\
                    return the current position of the caret.\n\
            \n\
                @return\n\
                    Index of the insert caret relative to the start of the text.\n\
                *\n" );
        
        }
        { //::CEGUI::Editbox::getMaskCodePoint
        
            typedef ::CEGUI::utf32 ( ::CEGUI::Editbox::*getMaskCodePoint_function_type )(  ) const;
            
            Editbox_exposer.def( 
                "getMaskCodePoint"
                , getMaskCodePoint_function_type( &::CEGUI::Editbox::getMaskCodePoint )
                , "*!\n\
                \n\
                    return the utf32 code point used when rendering masked text.\n\
            \n\
                @return\n\
                    utf32 code point value representing the Unicode code point that will be\n\
                    rendered instead of the Editbox text when rendering in masked mode.\n\
                *\n" );
        
        }
        { //::CEGUI::Editbox::getMaxTextLength
        
            typedef ::size_t ( ::CEGUI::Editbox::*getMaxTextLength_function_type )(  ) const;
            
            Editbox_exposer.def( 
                "getMaxTextLength"
                , getMaxTextLength_function_type( &::CEGUI::Editbox::getMaxTextLength )
                , "*!\n\
                \n\
                    return the maximum text length set for this Editbox.\n\
            \n\
                @return\n\
                    The maximum number of code points (characters) that can be entered into\n\
                    this Editbox.\n\
            \n\
                \note\n\
                    Depending on the validation string set, the actual length of text that\n\
                    can be entered may be less than the value returned here\n\
                    (it will never be more).\n\
                *\n" );
        
        }
        { //::CEGUI::Editbox::getSelectionEndIndex
        
            typedef ::size_t ( ::CEGUI::Editbox::*getSelectionEndIndex_function_type )(  ) const;
            
            Editbox_exposer.def( 
                "getSelectionEndIndex"
                , getSelectionEndIndex_function_type( &::CEGUI::Editbox::getSelectionEndIndex )
                , "*!\n\
                \n\
                    return the current selection end point.\n\
            \n\
                @return\n\
                    Index of the selection end point relative to the start of the text.  If\n\
                    no selection is defined this function returns the position of the caret.\n\
                *\n" );
        
        }
        { //::CEGUI::Editbox::getSelectionLength
        
            typedef ::size_t ( ::CEGUI::Editbox::*getSelectionLength_function_type )(  ) const;
            
            Editbox_exposer.def( 
                "getSelectionLength"
                , getSelectionLength_function_type( &::CEGUI::Editbox::getSelectionLength )
                , "*!\n\
                \n\
                    return the length of the current selection (in code points \n\
                    characters).\n\
            \n\
                @return\n\
                    Number of code points (or characters) contained within the currently\n\
                    defined selection.\n\
                *\n" );
        
        }
        { //::CEGUI::Editbox::getSelectionStartIndex
        
            typedef ::size_t ( ::CEGUI::Editbox::*getSelectionStartIndex_function_type )(  ) const;
            
            Editbox_exposer.def( 
                "getSelectionStartIndex"
                , getSelectionStartIndex_function_type( &::CEGUI::Editbox::getSelectionStartIndex )
                , "*!\n\
                \n\
                    return the current selection start point.\n\
            \n\
                @return\n\
                    Index of the selection start point relative to the start of the text.\n\
                    If no selection is defined this function returns the position of the\n\
                    caret.\n\
                *\n" );
        
        }
        { //::CEGUI::Editbox::getValidationString
        
            typedef ::CEGUI::String const & ( ::CEGUI::Editbox::*getValidationString_function_type )(  ) const;
            
            Editbox_exposer.def( 
                "getValidationString"
                , getValidationString_function_type( &::CEGUI::Editbox::getValidationString )
                , bp::return_value_policy< bp::copy_const_reference >()
                , "*!\n\
                \n\
                    return the currently set validation string\n\
            \n\
                \note\n\
                    Validation is performed by means of a regular expression.  If the text\n\
                    matches the regex, the text is said to have passed validation.  If the\n\
                    text does not match with the regex then the text fails validation.\n\
            \n\
                @return\n\
                    String object containing the current validation regex data\n\
                *\n" );
        
        }
        { //::CEGUI::Editbox::hasInputFocus
        
            typedef bool ( ::CEGUI::Editbox::*hasInputFocus_function_type )(  ) const;
            
            Editbox_exposer.def( 
                "hasInputFocus"
                , hasInputFocus_function_type( &::CEGUI::Editbox::hasInputFocus )
                , "*!\n\
                \n\
                    return true if the Editbox has input focus.\n\
            \n\
                @return\n\
                    - true if the Editbox has keyboard input focus.\n\
                    - false if the Editbox does not have keyboard input focus.\n\
                *\n" );
        
        }
        { //::CEGUI::Editbox::isReadOnly
        
            typedef bool ( ::CEGUI::Editbox::*isReadOnly_function_type )(  ) const;
            
            Editbox_exposer.def( 
                "isReadOnly"
                , isReadOnly_function_type( &::CEGUI::Editbox::isReadOnly )
                , "*!\n\
                \n\
                    return true if the Editbox is read-only.\n\
            \n\
                @return\n\
                    true if the Editbox is read only and can't be edited by the user, false\n\
                    if the Editbox is not read only and may be edited by the user.\n\
                *\n" );
        
        }
        { //::CEGUI::Editbox::isTextMasked
        
            typedef bool ( ::CEGUI::Editbox::*isTextMasked_function_type )(  ) const;
            
            Editbox_exposer.def( 
                "isTextMasked"
                , isTextMasked_function_type( &::CEGUI::Editbox::isTextMasked )
                , "*!\n\
                \n\
                    return true if the text for the Editbox will be rendered masked.\n\
            \n\
                @return\n\
                    true if the Editbox text will be rendered masked using the currently set\n\
                    mask code point, false if the Editbox text will be rendered as ordinary\n\
                    text.\n\
                *\n" );
        
        }
        { //::CEGUI::Editbox::isTextValid
        
            typedef bool ( ::CEGUI::Editbox::*isTextValid_function_type )(  ) const;
            
            Editbox_exposer.def( 
                "isTextValid"
                , isTextValid_function_type( &::CEGUI::Editbox::isTextValid )
                , "*!\n\
                \n\
                    return true if the Editbox text is valid given the currently set\n\
                    validation string.\n\
            \n\
                \note\n\
                    It is possible to programmatically set 'invalid' text for the Editbox by\n\
                    calling setText.  This has certain implications since if invalid text is\n\
                    set, whatever the user types into the box will be rejected when the\n\
                    input is validated.\n\
            \n\
                \note\n\
                    Validation is performed by means of a regular expression.  If the text\n\
                    matches the regex, the text is said to have passed validation.  If the\n\
                    text does not match with the regex then the text fails validation.\n\
            \n\
                @return\n\
                    - true if the current Editbox text passes validation.\n\
                    - false if the text does not pass validation.\n\
                *\n" );
        
        }
        { //::CEGUI::Editbox::setCaretIndex
        
            typedef void ( ::CEGUI::Editbox::*setCaretIndex_function_type )( ::size_t ) ;
            
            Editbox_exposer.def( 
                "setCaretIndex"
                , setCaretIndex_function_type( &::CEGUI::Editbox::setCaretIndex )
                , ( bp::arg("caret_pos") )
                , "*!\n\
                \n\
                    Set the current position of the caret.\n\
            \n\
                @param caret_pos\n\
                    New index for the insert caret relative to the start of the text.  If\n\
                    the value specified is greater than the number of characters in the\n\
                    Editbox, the caret is positioned at the end of the text.\n\
            \n\
                @return\n\
                    Nothing.\n\
                *\n" );
        
        }
        { //::CEGUI::Editbox::setMaskCodePoint
        
            typedef void ( ::CEGUI::Editbox::*setMaskCodePoint_function_type )( ::CEGUI::utf32 ) ;
            
            Editbox_exposer.def( 
                "setMaskCodePoint"
                , setMaskCodePoint_function_type( &::CEGUI::Editbox::setMaskCodePoint )
                , ( bp::arg("code_point") )
                , "*!\n\
                \n\
                    set the utf32 code point used when rendering masked text.\n\
            \n\
                @param code_point\n\
                    utf32 code point value representing the Unicode code point that should\n\
                    be rendered instead of the Editbox text when rendering in masked mode.\n\
            \n\
                @return\n\
                    Nothing.\n\
                *\n" );
        
        }
        { //::CEGUI::Editbox::setMaxTextLength
        
            typedef void ( ::CEGUI::Editbox::*setMaxTextLength_function_type )( ::size_t ) ;
            
            Editbox_exposer.def( 
                "setMaxTextLength"
                , setMaxTextLength_function_type( &::CEGUI::Editbox::setMaxTextLength )
                , ( bp::arg("max_len") )
                , "*!\n\
                \n\
                    set the maximum text length for this Editbox.\n\
            \n\
                @param max_len\n\
                    The maximum number of code points (characters) that can be entered into\n\
                    this Editbox.\n\
            \n\
                \note\n\
                    Depending on the validation string set, the actual length of text that\n\
                    can be entered may be less than the value set here\n\
                    (it will never be more).\n\
            \n\
                @return\n\
                    Nothing.\n\
                *\n" );
        
        }
        { //::CEGUI::Editbox::setReadOnly
        
            typedef void ( ::CEGUI::Editbox::*setReadOnly_function_type )( bool ) ;
            
            Editbox_exposer.def( 
                "setReadOnly"
                , setReadOnly_function_type( &::CEGUI::Editbox::setReadOnly )
                , ( bp::arg("setting") )
                , "*!\n\
                \n\
                    Specify whether the Editbox is read-only.\n\
            \n\
                @param setting\n\
                    true if the Editbox is read only and can't be edited by the user, false\n\
                    if the Editbox is not read only and may be edited by the user.\n\
            \n\
                @return\n\
                    Nothing.\n\
                *\n" );
        
        }
        { //::CEGUI::Editbox::setSelection
        
            typedef void ( ::CEGUI::Editbox::*setSelection_function_type )( ::size_t,::size_t ) ;
            
            Editbox_exposer.def( 
                "setSelection"
                , setSelection_function_type( &::CEGUI::Editbox::setSelection )
                , ( bp::arg("start_pos"), bp::arg("end_pos") )
                , "*!\n\
                \n\
                    Define the current selection for the Editbox\n\
            \n\
                @param start_pos\n\
                    Index of the starting point for the selection.  If this value is greater\n\
                    than the number of characters in the Editbox, the selection start will\n\
                    be set to the end of the text.\n\
            \n\
                @param end_pos\n\
                    Index of the ending point for the selection.  If this value is greater\n\
                    than the number of characters in the Editbox, the selection end will be\n\
                    set to the end of the text.\n\
            \n\
                @return\n\
                    Nothing.\n\
                *\n" );
        
        }
        { //::CEGUI::Editbox::setTextMasked
        
            typedef void ( ::CEGUI::Editbox::*setTextMasked_function_type )( bool ) ;
            
            Editbox_exposer.def( 
                "setTextMasked"
                , setTextMasked_function_type( &::CEGUI::Editbox::setTextMasked )
                , ( bp::arg("setting") )
                , "*!\n\
                \n\
                    Specify whether the text for the Editbox will be rendered masked.\n\
            \n\
                @param setting\n\
                    - true if the Editbox text should be rendered masked using the currently\n\
                      set mask code point.\n\
                    - false if the Editbox text should be rendered as ordinary text.\n\
            \n\
                @return\n\
                    Nothing.\n\
                *\n" );
        
        }
        { //::CEGUI::Editbox::setValidationString
        
            typedef void ( ::CEGUI::Editbox::*setValidationString_function_type )( ::CEGUI::String const & ) ;
            
            Editbox_exposer.def( 
                "setValidationString"
                , setValidationString_function_type( &::CEGUI::Editbox::setValidationString )
                , ( bp::arg("validation_string") )
                , "*!\n\
                \n\
                    Set the text validation string.\n\
            \n\
                \note\n\
                    Validation is performed by means of a regular expression.  If the text\n\
                    matches the regex, the text is said to have passed validation.  If the\n\
                    text does not match with the regex then the text fails validation.\n\
            \n\
                @param validation_string\n\
                    String object containing the validation regex data to be used.\n\
            \n\
                @return\n\
                    Nothing.\n\
                *\n" );
        
        }
        Editbox_exposer.add_static_property( "EventCaretMoved"
                        , bp::make_getter( &CEGUI::Editbox::EventCaretMoved
                                , bp::return_value_policy< bp::return_by_value >() ) );
        Editbox_exposer.add_static_property( "EventEditboxFull"
                        , bp::make_getter( &CEGUI::Editbox::EventEditboxFull
                                , bp::return_value_policy< bp::return_by_value >() ) );
        Editbox_exposer.add_static_property( "EventInvalidEntryAttempted"
                        , bp::make_getter( &CEGUI::Editbox::EventInvalidEntryAttempted
                                , bp::return_value_policy< bp::return_by_value >() ) );
        Editbox_exposer.add_static_property( "EventMaskCodePointChanged"
                        , bp::make_getter( &CEGUI::Editbox::EventMaskCodePointChanged
                                , bp::return_value_policy< bp::return_by_value >() ) );
        Editbox_exposer.add_static_property( "EventMaskedRenderingModeChanged"
                        , bp::make_getter( &CEGUI::Editbox::EventMaskedRenderingModeChanged
                                , bp::return_value_policy< bp::return_by_value >() ) );
        Editbox_exposer.add_static_property( "EventMaximumTextLengthChanged"
                        , bp::make_getter( &CEGUI::Editbox::EventMaximumTextLengthChanged
                                , bp::return_value_policy< bp::return_by_value >() ) );
        Editbox_exposer.add_static_property( "EventReadOnlyModeChanged"
                        , bp::make_getter( &CEGUI::Editbox::EventReadOnlyModeChanged
                                , bp::return_value_policy< bp::return_by_value >() ) );
        Editbox_exposer.add_static_property( "EventTextAccepted"
                        , bp::make_getter( &CEGUI::Editbox::EventTextAccepted
                                , bp::return_value_policy< bp::return_by_value >() ) );
        Editbox_exposer.add_static_property( "EventTextInvalidated"
                        , bp::make_getter( &CEGUI::Editbox::EventTextInvalidated
                                , bp::return_value_policy< bp::return_by_value >() ) );
        Editbox_exposer.add_static_property( "EventTextSelectionChanged"
                        , bp::make_getter( &CEGUI::Editbox::EventTextSelectionChanged
                                , bp::return_value_policy< bp::return_by_value >() ) );
        Editbox_exposer.add_static_property( "EventValidationStringChanged"
                        , bp::make_getter( &CEGUI::Editbox::EventValidationStringChanged
                                , bp::return_value_policy< bp::return_by_value >() ) );
        { //::CEGUI::Window::beginInitialisation
        
            typedef void ( ::CEGUI::Window::*beginInitialisation_function_type )(  ) ;
            typedef void ( Editbox_wrapper::*default_beginInitialisation_function_type )(  ) ;
            
            Editbox_exposer.def( 
                "beginInitialisation"
                , beginInitialisation_function_type(&::CEGUI::Window::beginInitialisation)
                , default_beginInitialisation_function_type(&Editbox_wrapper::default_beginInitialisation) );
        
        }
        { //::CEGUI::Window::cloneChildWidgetsTo
        
            typedef void ( ::CEGUI::Window::*cloneChildWidgetsTo_function_type )( ::CEGUI::Window & ) const;
            typedef void ( Editbox_wrapper::*default_cloneChildWidgetsTo_function_type )( ::CEGUI::Window & ) const;
            
            Editbox_exposer.def( 
                "cloneChildWidgetsTo"
                , cloneChildWidgetsTo_function_type(&::CEGUI::Window::cloneChildWidgetsTo)
                , default_cloneChildWidgetsTo_function_type(&Editbox_wrapper::default_cloneChildWidgetsTo)
                , ( bp::arg("target") ) );
        
        }
        { //::CEGUI::Window::clonePropertiesTo
        
            typedef void ( ::CEGUI::Window::*clonePropertiesTo_function_type )( ::CEGUI::Window & ) const;
            typedef void ( Editbox_wrapper::*default_clonePropertiesTo_function_type )( ::CEGUI::Window & ) const;
            
            Editbox_exposer.def( 
                "clonePropertiesTo"
                , clonePropertiesTo_function_type(&::CEGUI::Window::clonePropertiesTo)
                , default_clonePropertiesTo_function_type(&Editbox_wrapper::default_clonePropertiesTo)
                , ( bp::arg("target") ) );
        
        }
        { //::CEGUI::Window::destroy
        
            typedef void ( ::CEGUI::Window::*destroy_function_type )(  ) ;
            typedef void ( Editbox_wrapper::*default_destroy_function_type )(  ) ;
            
            Editbox_exposer.def( 
                "destroy"
                , destroy_function_type(&::CEGUI::Window::destroy)
                , default_destroy_function_type(&Editbox_wrapper::default_destroy) );
        
        }
        { //::CEGUI::Window::endInitialisation
        
            typedef void ( ::CEGUI::Window::*endInitialisation_function_type )(  ) ;
            typedef void ( Editbox_wrapper::*default_endInitialisation_function_type )(  ) ;
            
            Editbox_exposer.def( 
                "endInitialisation"
                , endInitialisation_function_type(&::CEGUI::Window::endInitialisation)
                , default_endInitialisation_function_type(&Editbox_wrapper::default_endInitialisation) );
        
        }
        { //::CEGUI::EventSet::fireEvent
        
            typedef void ( ::CEGUI::EventSet::*fireEvent_function_type )( ::CEGUI::String const &,::CEGUI::EventArgs &,::CEGUI::String const & ) ;
            typedef void ( Editbox_wrapper::*default_fireEvent_function_type )( ::CEGUI::String const &,::CEGUI::EventArgs &,::CEGUI::String const & ) ;
            
            Editbox_exposer.def( 
                "fireEvent"
                , fireEvent_function_type(&::CEGUI::EventSet::fireEvent)
                , default_fireEvent_function_type(&Editbox_wrapper::default_fireEvent)
                , ( bp::arg("name"), bp::arg("args"), bp::arg("eventNamespace")="" ) );
        
        }
        { //::CEGUI::Window::getRenderedStringParser
        
            typedef ::CEGUI::RenderedStringParser & ( ::CEGUI::Window::*getRenderedStringParser_function_type )(  ) const;
            
            Editbox_exposer.def( 
                "getRenderedStringParser"
                , getRenderedStringParser_function_type(&::CEGUI::Window::getRenderedStringParser)
                , bp::return_value_policy< bp::reference_existing_object >() );
        
        }
        { //::CEGUI::Window::getRenderingContext_impl
        
            typedef void ( ::CEGUI::Window::*getRenderingContext_impl_function_type )( ::CEGUI::RenderingContext & ) const;
            typedef void ( Editbox_wrapper::*default_getRenderingContext_impl_function_type )( ::CEGUI::RenderingContext & ) const;
            
            Editbox_exposer.def( 
                "getRenderingContext_impl"
                , getRenderingContext_impl_function_type(&::CEGUI::Window::getRenderingContext_impl)
                , default_getRenderingContext_impl_function_type(&Editbox_wrapper::default_getRenderingContext_impl)
                , ( bp::arg("ctx") ) );
        
        }
        { //::CEGUI::Window::getUnclippedInnerRect_impl
        
            typedef ::CEGUI::Rect ( ::CEGUI::Window::*getUnclippedInnerRect_impl_function_type )(  ) const;
            typedef ::CEGUI::Rect ( Editbox_wrapper::*default_getUnclippedInnerRect_impl_function_type )(  ) const;
            
            Editbox_exposer.def( 
                "getUnclippedInnerRect_impl"
                , getUnclippedInnerRect_impl_function_type(&::CEGUI::Window::getUnclippedInnerRect_impl)
                , default_getUnclippedInnerRect_impl_function_type(&Editbox_wrapper::default_getUnclippedInnerRect_impl) );
        
        }
        { //::CEGUI::Window::initialiseComponents
        
            typedef void ( ::CEGUI::Window::*initialiseComponents_function_type )(  ) ;
            typedef void ( Editbox_wrapper::*default_initialiseComponents_function_type )(  ) ;
            
            Editbox_exposer.def( 
                "initialiseComponents"
                , initialiseComponents_function_type(&::CEGUI::Window::initialiseComponents)
                , default_initialiseComponents_function_type(&Editbox_wrapper::default_initialiseComponents) );
        
        }
        { //::CEGUI::Window::isHit
        
            typedef bool ( ::CEGUI::Window::*isHit_function_type )( ::CEGUI::Vector2 const &,bool const ) const;
            typedef bool ( Editbox_wrapper::*default_isHit_function_type )( ::CEGUI::Vector2 const &,bool const ) const;
            
            Editbox_exposer.def( 
                "isHit"
                , isHit_function_type(&::CEGUI::Window::isHit)
                , default_isHit_function_type(&Editbox_wrapper::default_isHit)
                , ( bp::arg("position"), bp::arg("allow_disabled")=(bool const)(false) ) );
        
        }
        { //::CEGUI::Window::performChildWindowLayout
        
            typedef void ( ::CEGUI::Window::*performChildWindowLayout_function_type )(  ) ;
            typedef void ( Editbox_wrapper::*default_performChildWindowLayout_function_type )(  ) ;
            
            Editbox_exposer.def( 
                "performChildWindowLayout"
                , performChildWindowLayout_function_type(&::CEGUI::Window::performChildWindowLayout)
                , default_performChildWindowLayout_function_type(&Editbox_wrapper::default_performChildWindowLayout) );
        
        }
        { //::CEGUI::Window::setLookNFeel
        
            typedef void ( ::CEGUI::Window::*setLookNFeel_function_type )( ::CEGUI::String const & ) ;
            typedef void ( Editbox_wrapper::*default_setLookNFeel_function_type )( ::CEGUI::String const & ) ;
            
            Editbox_exposer.def( 
                "setLookNFeel"
                , setLookNFeel_function_type(&::CEGUI::Window::setLookNFeel)
                , default_setLookNFeel_function_type(&Editbox_wrapper::default_setLookNFeel)
                , ( bp::arg("look") ) );
        
        }
        { //::CEGUI::Window::setMargin
        
            typedef void ( ::CEGUI::Window::*setMargin_function_type )( ::CEGUI::UBox const & ) ;
            typedef void ( Editbox_wrapper::*default_setMargin_function_type )( ::CEGUI::UBox const & ) ;
            
            Editbox_exposer.def( 
                "setMargin"
                , setMargin_function_type(&::CEGUI::Window::setMargin)
                , default_setMargin_function_type(&Editbox_wrapper::default_setMargin)
                , ( bp::arg("margin") ) );
        
        }
        { //::CEGUI::EventSet::subscribeScriptedEvent
        
            typedef ::CEGUI::RefCounted< CEGUI::BoundSlot > ( ::CEGUI::EventSet::*subscribeScriptedEvent_function_type )( ::CEGUI::String const &,::CEGUI::String const & ) ;
            typedef ::CEGUI::RefCounted< CEGUI::BoundSlot > ( Editbox_wrapper::*default_subscribeScriptedEvent_function_type )( ::CEGUI::String const &,::CEGUI::String const & ) ;
            
            Editbox_exposer.def( 
                "subscribeScriptedEvent"
                , subscribeScriptedEvent_function_type(&::CEGUI::EventSet::subscribeScriptedEvent)
                , default_subscribeScriptedEvent_function_type(&Editbox_wrapper::default_subscribeScriptedEvent)
                , ( bp::arg("name"), bp::arg("subscriber_name") ) );
        
        }
        { //::CEGUI::EventSet::subscribeScriptedEvent
        
            typedef ::CEGUI::RefCounted< CEGUI::BoundSlot > ( ::CEGUI::EventSet::*subscribeScriptedEvent_function_type )( ::CEGUI::String const &,unsigned int,::CEGUI::String const & ) ;
            typedef ::CEGUI::RefCounted< CEGUI::BoundSlot > ( Editbox_wrapper::*default_subscribeScriptedEvent_function_type )( ::CEGUI::String const &,unsigned int,::CEGUI::String const & ) ;
            
            Editbox_exposer.def( 
                "subscribeScriptedEvent"
                , subscribeScriptedEvent_function_type(&::CEGUI::EventSet::subscribeScriptedEvent)
                , default_subscribeScriptedEvent_function_type(&Editbox_wrapper::default_subscribeScriptedEvent)
                , ( bp::arg("name"), bp::arg("group"), bp::arg("subscriber_name") ) );
        
        }
        { //::CEGUI::Window::update
        
            typedef void ( ::CEGUI::Window::*update_function_type )( float ) ;
            typedef void ( Editbox_wrapper::*default_update_function_type )( float ) ;
            
            Editbox_exposer.def( 
                "update"
                , update_function_type(&::CEGUI::Window::update)
                , default_update_function_type(&Editbox_wrapper::default_update)
                , ( bp::arg("elapsed") ) );
        
        }
        { //::CEGUI::Window::writeXMLToStream
        
            typedef void ( ::CEGUI::Window::*writeXMLToStream_function_type )( ::CEGUI::XMLSerializer & ) const;
            typedef void ( Editbox_wrapper::*default_writeXMLToStream_function_type )( ::CEGUI::XMLSerializer & ) const;
            
            Editbox_exposer.def( 
                "writeXMLToStream"
                , writeXMLToStream_function_type(&::CEGUI::Window::writeXMLToStream)
                , default_writeXMLToStream_function_type(&Editbox_wrapper::default_writeXMLToStream)
                , ( bp::arg("xml_stream") ) );
        
        }
    }

}
